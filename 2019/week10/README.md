## ARTS(week10)

### 算法题(Algorithm)

[有效的数独](https://github.com/geekwho11/learn.leetcode.xbcme/tree/master/php/src/36.valid-sudoku)

### 阅读点评(Review)

#### [InnoDB Multi-Versioning](https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html)

#### 阅读笔记

InnoDB是一个多版本的存储引擎：它保存已更改行旧版本的有关信息，以支持并发和回滚等事务特性。此信息是存储在表空间中，称为回滚段的数据结构（在Oracle中的类似数据结构之后）。 InnoDB使用回滚段中的信息来执行事务回滚中所需的撤消操作。它还使用该信息构建早期版本的行以进行一致读取。

在内部，InnoDB为存储在数据库中的每一行添加三个字段。 6字节的DB_TRX_ID字段指示插入或更新该行的最后一个事务的事务标识符。此外，删除在内部被视为更新，其中行中的特殊位被设置为将其标记为已删除。每行还包含一个7字节的DB_ROLL_PTR字段，称为滚动指针。滚动指针指向写入回滚段的撤消日志记录。如果更新了行，则撤消日志记录包含在更新行之前重建行内容所需的信息。 6字节的DB_ROW_ID字段包含在插入新行时单调增加的行ID。如果InnoDB自动生成聚簇索引，则索引包含行ID值。否则，DB_ROW_ID列不会出现在任何索引中。

回滚段中的撤消日志分为插入和更新撤消日志。只在事务回滚中需要插入撤消日志，并且可以在事务提交后立即丢弃。更新撤消日志也用于一致性读取，但只有在InnoDB没有分配快照的事务之后才能丢弃它们，在一致读取中可能需要更新撤消日志中的信息来构建早期版本的数据库行。

定期提交您的交易，包括那些只发出一致读取的交易。否则，InnoDB无法丢弃更新撤消日志中的数据，并且回滚段可能会变得太大，从而填满了表空间。

回滚段中的撤消日志记录的物理大小通常小于相应的插入或更新的行。您可以使用此信息计算回滚段所需的空间。

在InnoDB多版本控制方案中，当您使用SQL语句删除行时，不会立即从数据库中物理删除该行。 InnoDB在丢弃为删除写入的更新撤消日志记录时，仅物理删除相应的行及其索引记录。此删除操作称为清除，并且速度非常快，通常与执行删除的SQL语句的时间顺序相同。

如果你在表中以大约相同的速率插入和删除少量批次的行，则清除线程可能开始落后，并且由于所有“死”行，表可以变得越来越大，使得所有内容都受磁盘约束慢。在这种情况下，通过调整innodb_max_purge_lag系统变量来限制新行操作，并为清除线程分配更多资源。

##### 多版本控制和二级索引

InnoDB多版本并发控制（MVCC）以不同于聚簇索引的方式处理二级索引。聚簇索引中的记录就地更新，其隐藏的系统列指向可以重建早期版本记录的撤消日志条目。与聚簇索引记录不同，二级索引记录不包含隐藏的系统列，也不会就地更新。

更新二级索引列时，旧的二级索引记录将被删除标记，插入新记录，最终清除删除标记的记录。当二级索引记录被删除标记或二级索引页面由较新的事务更新时，InnoDB在聚簇索引中查找数据库记录。在聚簇索引中，将检查记录的DB_TRX_ID，如果在启动读取事务后修改了记录，则会从撤消日志中检索正确的记录版本。

如果二级索引记录被标记为删除或二级索引页面由较新的事务更新，则不使用覆盖索引技术。 InnoDB不是从索引结构返回值，而是在聚簇索引中查找记录。

但是，如果启用了索引条件下推（ICP）优化，并且可以仅使用索引中的字段来评估WHERE条件的某些部分，则MySQL服务器仍会将WHERE条件的这一部分向下推送到评估它的存储引擎使用索引。如果未找到匹配的记录，则避免聚簇索引查找。如果找到匹配的记录，即使在删除标记的记录中，InnoDB也会在聚簇索引中查找记录。

### 技术技巧(Tip)

#### 位运算

| 例子             | 名称              | 结果                                 |
| -------------- | --------------- | ---------------------------------- |
| ```$a & $b```  | And（按位与）        | 将把 $a 和 $b 中都为 1 的位设为 1。           |
| ```$a | $b```  | Or（按位或）         | 将把 $a 和 $b 中任何一个为 1 的位设为 1。        |
| ```$a ^ $b```  | Xor（按位异或）       | 将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1。   |
| ```~ $a```     | Not（按位取反）       | 将 $a 中为 0 的位设为 1，反之亦然。             |
| ```$a << $b``` | Shift left（左移）  | 将 $a 中的位向左移动 $b 次（每一次移动都表示“乘以 2”）。 |
| ```$a >> $b``` | Shift right（右移） | 将 $a 中的位向右移动 $b 次（每一次移动都表示“除以 2”）。 |

#### 应用

```
PHP 的 ini 设定 error_reporting 使用了按位的值，
提供了关闭某个位的真实例子。要显示除了提示级别
之外的所有错误，php.ini 中是这样用的：
E_ALL & ~E_NOTICE

具体运作方式是先取得 E_ALL 的值：
00000000000000000111011111111111
再取得 E_NOTICE 的值：
00000000000000000000000000001000
然后通过 ~ 将其取反：
11111111111111111111111111110111
最后再用按位与 AND（&）得到两个值中都设定了（为 1）的位：
00000000000000000111011111110111
```

这里有点难理解，那现在得到这个值后，error_reporting是如何进行对比的呢？

1. 如何判断 E_NOTICE级别是否可以显示呢？

2. ```
   $error= E_NOTICE & (E_ALL & ~E_NOTICE) = 0 
   ```

3. 如何判断 E_ERROR E_WARNING级别是否可以显示错误呢？

4. ```
   $error= E_ERROR & (E_ALL & ~E_NOTICE) = 1
   $error= E_WARNING & (E_ALL & ~E_NOTICE) = 2
   ```

### 分享(Share)

#### [PHP 进阶之路 - 揭开 PHP 线程安全的神秘面纱](https://segmentfault.com/a/1190000010004035)

#### 阅读笔记

#### 函数作用域

| 变量类型                           | 函数     | 线程   | 备注   |
| ------------------------------ | ------ | ---- | ---- |
| 全局变量（`int gVar;`）              | 所有函数共享 | 共享   |      |
| 静态全局变量（`static sgVar`）         | 所有函数共享 | 共享   |      |
| 局部变量（函数/块内的`int var;`）         | 函数相互独立 | 不共享  |      |
| 局部静态变量(函数中的`static int sVar;`) | 本函数间共享 | 共享   |      |

#### 线程安全资源管理器的由来

同一进程中的多线程公用模块初始化相关的全局变量，当多线程并发时，会同时修改一些变量，导致数据一致性或资源竞争等问题。为解决线程的并发问题，PHP 引入了 TSRM： 线程安全资源管理器(Thread Safe Resource Manager)。 

#### TSRM的实现

进程保留着资源所有权的属性，线程做并发访问，PHP 中引入的 TSRM 层关注的是对共享资源的访问， 这里的共享资源是线程之间共享的存在于进程的内存空间的全局变量。 当 PHP 在单进程模式下时，一个变量被声明在任何函数之外时，就成为一个全局变量。

首先定义了如下几个非常重要的全局变量（这里的全局变量是多线程共享的）。

其中涉及到两个关键的数据结构 `tsrm_tls_entry` 和 `tsrm_resource_type`。

当新增一个全局变量时，`id_count` 会自增1（加上线程互斥锁）。然后根据全局变量需要的内存、构造函数、析构函数生成对应的资源`tsrm_resource_type`，存入 `*resource_types_table`，再根据该资源，为每个线程的所有`tsrm_tls_entry`节点添加其对应的全局变量。

#### TSRM 环境的初始化

模块初始化阶段，在各个 SAPI main 函数中通过调用 `tsrm_startup` 来初始化 TSRM 环境。`tsrm_startup` 函数会传入两个非常重要的参数，一个是 `expected_threads`，表示预期的线程数， 一个是 `expected_resources`，表示预期的资源数。不同的 SAPI 有不同的初始化值，比如mod_php5，cgi 这些都是一个线程一个资源。

精简出其中完成的三个重要的工作，初始化了 tsrm_tls_table 链表、resource_types_table 数组，以及 id_count。而这三个全局变量是所有线程共享的，实现了线程间的内存管理的一致性。

#### 资源 ID 的分配

当通过 ts_allocate_id 函数分配全局资源 ID 时，PHP 内核会先加上互斥锁，确保生成的资源 ID 的唯一，这里锁的作用是在时间维度将并发的内容变成串行，因为并发的根本问题就是时间的问题。当加锁以后，id_count 自增，生成一个资源 ID，生成资源 ID 后，就会给当前资源 ID 分配存储的位置，
每一个资源都会存储在 resource_types_table 中，当一个新的资源被分配时，就会创建一个 tsrm_resource_type。
所有 tsrm_resource_type 以数组的方式组成 tsrm_resource_table，其下标就是这个资源的 ID。
其实我们可以将 tsrm_resource_table 看做一个 HASH 表，key 是资源 ID，value 是 tsrm_resource_type 结构（任何一个数组都可以看作一个 HASH 表，如果数组的key 值有意义的话）。

在分配了资源 ID 后，PHP 内核会接着遍历所有线程为每一个线程的 tsrm_tls_entry 分配这个线程全局变量需要的内存空间。
这里每个线程全局变量的大小在各自的调用处指定（也就是全局变量结构体的大小）。最后对地址存放的全局变量进行初始化。

#### 全局变量的使用

 Zend Thread Safety ZTS

上面有一个知识点，Thread Local Storage ，现在有一全局变量 **tls_key**，所有线程都可以使用它，改变它的值。
表面上看起来这是一个全局变量，所有线程都可以使用它，而它的值在每一个线程中又是单独存储的。这就是线程本地存储的意义。

#### 参考链接

1. [第三节 PHP中的线程安全](https://github.com/zhoumengkang/tipi/blob/master/book/chapt08/08-03-zend-thread-safe-in-php.markdown)