## ARTS(week11)

### 算法题(Algorithm)

[旋转图像](https://github.com/geekwho11/learn.leetcode.xbcme/tree/master/php/src/48.rotate-image)

### 阅读点评(Review)

#### [Phantom Rows](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html)

#### 阅读笔记

当同一查询在不同时间产生不同的行集时，所谓的幻像问题发生在事务中。 例如，如果SELECT执行两次，但第二次返回第二次没有返回的行，则该行是“幻像”行。

假设子表的id列上有一个索引，并且您要读取并锁定标识符值大于100的表中的所有行，以便稍后更新所选行中的某些列：

```
SELECT * FROM child WHERE id > 100 FOR UPDATE;
```

查询从id大于100的第一个记录开始扫描索引。让表包含id值为90和102的行。如果在扫描范围内的索引记录上设置的锁不会锁定在间隙（在这种情况下，在90和102之间的间隙），另一个会话可以在表中插入一个id为101的新行。如果你要在同一个事务中执行相同的SELECT，你会看到一个新行查询返回的结果集中的id为101（“幻像”）。如果我们将一组行视为数据项，则新的幻像子将违反事务应该能够运行的事务的隔离原则，以便它在事务期间读取的数据不会更改。

为了防止幻像，InnoDB使用一种称为下一键锁定的算法，它将索引行锁定与间隙锁定相结合。 InnoDB以这样的方式执行行级锁定：当它搜索或扫描表索引时，它会在遇到的索引记录上设置共享锁或排它锁。因此，行级锁实际上是索引记录锁。此外，索引记录上的下一键锁定也会影响该索引记录之前的“间隙”。也就是说，下一键锁定是索引记录锁定加上索引记录之前的间隙上的间隙锁定。如果一个会话在索引中的记录R上具有共享锁或独占锁，则另一个会话不能在索引顺序中的R之前的间隙中插入新的索引记录。

当InnoDB扫描索引时，它也可以锁定索引中最后一条记录之后的间隙。就在前面的例子中发生了这样的情况：为了防止任何插入到id大于100的表中，InnoDB设置的锁包括在id值102之后的空位上的锁。

您可以使用下一键锁定在应用程序中实现唯一性检查：如果您在共享模式下读取数据并且没有看到要插入的行的副本，那么您可以安全地插入行并知道在读取期间在行的后继上设置的下一键锁定可防止任何人同时为您的行插入副本。因此，下一键锁定使您能够“锁定”表中某些内容的不存在。

可以禁用间隙锁定，如第15.7.1节“InnoDB锁定”中所述。这可能会导致幻像问题，因为其他会话可以在禁用间隙锁定时将新行插入间隙。

### 技术技巧(Tip)

#### 守护进程

正确的来说，在Linux环境下如何正确的实现一个守护进程的程序？

成为守护进程必要条件：

1. 创建子进程，父进程退出
2. 子进程创建新会话
3. 改变当前目录
4. 重设文件权限掩码
5. 关闭文件描述符

| 相关函数            | 作用         | 备注         |
| --------------- | ---------- | ---------- |
| pcntl_fork_fork | fork子进程    | 需安装pcntl扩展 |
| posix_setsid    | 使当前进程成为组长  | 需安装posix扩展 |
| chdir           | 改变工作目录     |            |
| umask           | 重新设置文件掩码   |            |
| fclose          | 关闭打开的文件描述符 |            |

#### 参考链接
1. [如何实现守护进程](https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/Daemon.md)
2. [PHP 编写守护进程](https://laravel-china.org/index.php/articles/22483)
3. [PHP程序守护进程化](http://rango.swoole.com/archives/59)

### 分享(Share)

#### [第一节 生命周期和Zend引擎](http://www.php-internals.com/book/?p=chapt02/02-01-php-life-cycle-and-zend-engine)

#### 阅读笔记

#####  开始和结束

PHP开始执行以后会经过两个主要的阶段：处理请求之前的开始阶段和请求之后的结束阶段。

| 步骤          | 执行             | 备注   |
| ----------- | -------------- | ---- |
| 处理请求之前的开始阶段 | 模块初始化阶段（MINIT） |      |
|             |                |      |
| 请求          | 初始化基本环境        |      |
|             | 模块激活阶段（RINIT）  |      |
|             | 执行脚本           |      |
|             |                |      |
| 请求之后的结束阶段   | 停用模块 RSHUTDOWN |      |
|             | 模块关闭 MSHUTDOWN |      |

##### 单进程SAPI生命周期

| 步骤              | 实现细节 | 备注   |
| --------------- | ---- | ---- |
| php -f test.php |      |      |
| 调用扩展的MINIT      |      |      |
| 请求 test.php     | 独立请求 |      |
| 调用扩展RINIT       | 独立请求 |      |
| 执行 test.php     | 独立请求 |      |
| 调用扩展的RSHUTDOWN  | 独立请求 |      |
| 完成执行后清理         | 独立请求 |      |
| 调用扩展MSHUTDOWN   |      |      |

##### 多进程SAPI生命周期

通常PHP是编译为apache的一个模块来处理PHP请求。Apache一般会采用多进程模式， Apache启动后会fork出多个子进程，每个进程的内存空间独立，每个子进程都会经过开始和结束环节， 不过每个进程的开始阶段只在进程fork出来以来后进行，在整个进程的生命周期内可能会处理多个请求。 只有在Apache关闭或者进程被结束之后才会进行关闭阶段，在这两个阶段之间会随着每个请求重复请求开始-请求关闭的环节。

| 步骤        | 并行执行 | 备注   |
| --------- | ---- | ---- |
| MINIT     |      | 执行一次 |
| RINIT     |      |      |
| Script    |      |      |
| RSHUTDOWN |      |      |
| RINIT     |      |      |
| Script    |      |      |
| RSHUTDOWN |      |      |
| MSHUTDOWN |      | 执行一次 |

##### 多线程的SAPI生命周期

多线程模式和多进程中的某个进程类似，不同的是在整个进程的生命周期内会**并行**的重复着 请求开始-请求关闭的环节。

| 步骤        | 并行执行      | 备注   |
| --------- | --------- | ---- |
| MINIT     |           | 执行一次 |
|           | RINIT     | 执行多次 |
|           | Script    | 执行脚本 |
|           | RSHUTDOWN |      |
| MSHUTDOWN |           | 执行一次 |