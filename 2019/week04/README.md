## ARTS(week04)

### 算法题(Algorithm)

[存在重复](https://github.com/geekwho11/learn.leetcode.xbcme/tree/master/php/src/217.contains-duplicate)

### 阅读点评(Review)

#### [Best Practices for Azure Redis](https://gist.github.com/JonCole/925630df72be1351b21440625ff2671f#file-redis-bestpractices-general-md)

#### 阅读笔记

Azure在Redis方面的最佳实践

##### 配置相关

1. 在生产环境最好使用标准或者高级应用层。
2. 请记住，Redis是一个内存数据存储服务。
3. 尝试配置你的客户端连接超时为10-15s。
4. 优化你的系统，使之可以处理由于修复或者故障转移的连接闪烁
5. 配置好你的最大保留内存设置，改善系统在内存压力下的表现，特别是在比较大的写入操作，或者在Redis存储较大的值100KB或更多。
6. Redis在适合使用较小的值，因此请考虑将更大的数据拆分为多个比较小的值。
7. 确保你的缓存实例和应用程序，最好在同一个区域或者内网。
8. 创建新连接是非常昂贵且会增加延迟，因此建议尽可能的重用连接。
9. 避免耗时操作

##### 内存管理

1. 为你的应用选择合适的内存回收算法。比如Azure默认是volitile-lru。这意味着只有在缓存到期后，才会进行回收。如果没有过期的缓存，那么客户端在写入时会出报内初不足的错误。
2. 为你的所有key设置一个过期时间。

##### 什么时候重试是安全的

1. 即使服务器成功运行了你的命令，客户端也可能收到错误。超时是客户端的概念。如果命令已经达到服务器，即使客户端放弃等待，服务器也会运行该命令。当socket出现连接错误时，无论操作是否在服务器执行了，结果都是不确定的。例如，连接错误出现在服务器处理请求之后但客户端收到响应之前。
2. 如果意外的运行两次相同的命令，应用程序的结果是？

##### 性能测试

1. 使用**redis-benchmark**
2. 用户测试的客户端和正式的缓存实例应该保持一致，同一内网，同一配置。

### 技术技巧(Tip)

SETEX key seconds value

设置key的值和过期时间，如果key存在就覆盖原来的值，属于原子操作。

```
SETEX key value 60
```

可用于实现分布式锁。

#### 分布式锁

##### 单机的正确实现

1. ```
   SET resource_name my_random_value NX PX 30000
   ```

2. set设置nx px属性，仅在不存在key的时候才能被执行成功，并且设置一个30s自动失效时间。

3. 采用客户端随机值，为了更安全的释放锁。只有对应的值相同才能删除锁，采用lua脚本实现。

4. 避免异常情况下，客户端A意外删除客户端B的锁。

##### 集群

1. 获取时间戳，以毫秒为单位。
2. 依次尝试N个实例，使用相同的key和随机值获取锁，并且设置网络连接和响应超时的时间，最好小于锁失效时间。
3. 客户端，计算获取锁花费的时间=当前时间-开始获取锁的时间。至少n/2+1个节点都获取到锁，所花费的时间小于失效时间，才能确认锁获取成功
4. 如果获取到了锁，真正有效时间=设置的有效时间-获取锁花费的时间。
5. 依次对每一个实例进行解锁，就算没有加锁成功，也需要进行解锁。

#### 参考链接

1. [分布式锁](http://www.redis.cn/topics/distlock)
2. [redlock-php](https://github.com/ronnylt/redlock-php)

### 分享(Share)

#### [redis加锁的几种实现](http://ukagaka.github.io/php/2017/09/21/redisLock.html)

#### 阅读笔记

##### 问题1

Redis第一次设置锁失败，怎么办？

解决方案：设置循环语句，执行锁请求。

##### 问题2

多个客户端并发请求，如果都是循环的话，会发生抢锁的可能，如何解决？

解决方案：休眠5s

##### 问题3

锁提前过期，客户端A还在执行中，客户端B获取了锁，这时候，如果客户端A执行完成，是否有可能意外的删除B的锁？

解决方案：针对每一个客户端建立自己的签名标识，只允许删除自己创建的锁，无法删除其他客户端的锁。

##### 参考代码

```
do {  //针对问题1，使用循环
  $timeout = 10;
  $roomid = 10001;
  $key = 'room_lock';
  $value = 'room_'.$roomid;  //分配一个随机的值针对问题3
  $isLock = Redis::set($key, $value, 'ex', $timeout, 'nx');//ex 秒
  if ($isLock) {
    if (Redis::get($key) == $value) {  //防止提前过期，误删其它请求创建的锁
    //执行内部代码
      Redis::del($key);
      continue;//执行成功删除key并跳出循环
     }
   } else {
     usleep(5000); //睡眠，降低抢锁频率，缓解redis压力，针对问题2
   }
} while(!$isLock);
```